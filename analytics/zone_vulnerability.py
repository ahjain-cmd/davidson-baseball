"""Zone-level vulnerability analysis — extracted from scouting.py for reuse.

Provides importable functions for computing zone swing metrics, zone patterns,
swing path vulnerability, and a condensed summary dict for the decision engine.
"""
from __future__ import annotations

from typing import Any, Dict, Optional, Tuple

import numpy as np
import pandas as pd

from config import is_barrel_mask, SWING_CALLS


# ── Constants for hole-score computation ────────────────────────────────────
_AB_RESULTS = {
    "Single", "Double", "Triple", "HomeRun",
    "Out", "Strikeout", "FieldersChoice", "Error",
}

_TB_MAP = {"Single": 1, "Double": 2, "Triple": 3, "HomeRun": 4}


def _assign_total_bases(play_result) -> int:
    """Map Trackman PlayResult to total bases for SLG calculation."""
    return _TB_MAP.get(play_result, 0)


def _fmt_bats(bats) -> str:
    if bats is None or (isinstance(bats, float) and pd.isna(bats)):
        return "?"
    b = str(bats).strip()
    mapping = {"Right": "R", "Left": "L", "Both": "S", "Switch": "S", "R": "R", "L": "L", "S": "S"}
    return mapping.get(b, b)


def _rel_xbin(xb: int, bats) -> int:
    """Convert absolute x-bin (0=left,2=right) to hitter-relative (0=inside,2=away)."""
    label = _fmt_bats(bats)
    if label == "L":
        return 2 - xb
    return xb


def compute_zone_swing_metrics(df: pd.DataFrame, bats) -> Optional[Dict]:
    """Compute data-driven swing efficiency metrics by zone (3x3 grid).

    Returns a dict keyed by (xbin, ybin) with metrics:
    - la_mean, la_std, optimal_la_delta, ev_mean, hard_hit_pct, barrel_pct, n_pitches, n_contact
    """
    d = df.dropna(subset=["PlateLocSide", "PlateLocHeight"]).copy()
    if d.empty:
        return None

    x_edges = np.array([-1.5, -0.5, 0.5, 1.5])
    y_edges = np.array([0.5, 2.0, 3.0, 4.5])
    d["xbin"] = np.clip(np.digitize(d["PlateLocSide"], x_edges) - 1, 0, 2)
    d["ybin"] = np.clip(np.digitize(d["PlateLocHeight"], y_edges) - 1, 0, 2)

    optimal_la = {0: 8.0, 1: 14.0, 2: 20.0}

    metrics: Dict = {}
    for yb in range(3):
        for xb in range(3):
            zdf = d[(d["xbin"] == xb) & (d["ybin"] == yb)]
            ip = zdf[zdf["PitchCall"] == "InPlay"].copy() if "PitchCall" in zdf.columns else pd.DataFrame()

            m: Dict[str, Any] = {"n_pitches": len(zdf), "n_contact": len(ip)}

            if len(ip) >= 3 and "Angle" in ip.columns:
                la_vals = pd.to_numeric(ip["Angle"], errors="coerce").dropna()
                if len(la_vals) >= 3:
                    m["la_mean"] = la_vals.mean()
                    m["la_std"] = la_vals.std()
                    m["optimal_la_delta"] = abs(la_vals.mean() - optimal_la[yb])

            if len(ip) >= 3 and "ExitSpeed" in ip.columns:
                ev_vals = pd.to_numeric(ip["ExitSpeed"], errors="coerce").dropna()
                if len(ev_vals) >= 3:
                    m["ev_mean"] = ev_vals.mean()
                    m["hard_hit_pct"] = (ev_vals >= 95).mean() * 100

            if len(ip) >= 3 and {"ExitSpeed", "Angle"}.issubset(ip.columns):
                ip_ba = ip.dropna(subset=["ExitSpeed", "Angle"])
                if len(ip_ba) >= 3:
                    m["barrel_pct"] = is_barrel_mask(ip_ba).mean() * 100

            metrics[(xb, yb)] = m

    return metrics


def analyze_zone_patterns(zone_metrics: Optional[Dict], bats) -> Dict:
    """Analyze horizontal (inside/outside) and vertical (up/down) swing patterns.

    Returns dict with pattern descriptions and aggregated hard-hit rates.
    """
    if zone_metrics is None:
        return {}

    inside_hh, middle_hh, away_hh = [], [], []
    inside_barrel, away_barrel = [], []

    for (xb, yb), m in zone_metrics.items():
        xb_rel = _rel_xbin(xb, bats)
        hh = m.get("hard_hit_pct")
        barrel = m.get("barrel_pct")
        if hh is not None and not pd.isna(hh) and m.get("n_contact", 0) >= 3:
            if xb_rel == 0:
                inside_hh.append(hh)
            elif xb_rel == 1:
                middle_hh.append(hh)
            else:
                away_hh.append(hh)
        if barrel is not None and not pd.isna(barrel) and m.get("n_contact", 0) >= 3:
            if xb_rel == 0:
                inside_barrel.append(barrel)
            elif xb_rel == 2:
                away_barrel.append(barrel)

    result: Dict[str, Any] = {}

    in_hh_avg = np.mean(inside_hh) if inside_hh else np.nan
    away_hh_avg = np.mean(away_hh) if away_hh else np.nan
    in_barrel_avg = np.mean(inside_barrel) if inside_barrel else np.nan
    away_barrel_avg = np.mean(away_barrel) if away_barrel else np.nan

    result["inside_hh_pct"] = in_hh_avg
    result["away_hh_pct"] = away_hh_avg

    # Horizontal pattern
    h_pattern = "balanced"
    if not pd.isna(in_hh_avg) and not pd.isna(away_hh_avg):
        diff = in_hh_avg - away_hh_avg
        if diff > 12:
            h_pattern = "crushes inside, struggles away"
        elif diff > 6:
            h_pattern = "prefers inside"
        elif diff < -12:
            h_pattern = "crushes away, struggles inside"
        elif diff < -6:
            h_pattern = "prefers away"

    if not pd.isna(in_barrel_avg) and not pd.isna(away_barrel_avg):
        barrel_diff = in_barrel_avg - away_barrel_avg
        if barrel_diff > 8 and "away" not in h_pattern:
            h_pattern = "barrels inside, not away"
        elif barrel_diff < -8 and "inside" not in h_pattern:
            h_pattern = "barrels away, not inside"

    result["horizontal_pattern"] = h_pattern

    # Vertical pattern
    down_hh, up_hh = [], []
    for (xb, yb), m in zone_metrics.items():
        hh = m.get("hard_hit_pct")
        if hh is not None and not pd.isna(hh) and m.get("n_contact", 0) >= 3:
            if yb == 0:
                down_hh.append(hh)
            elif yb == 2:
                up_hh.append(hh)

    down_hh_avg = np.mean(down_hh) if down_hh else np.nan
    up_hh_avg = np.mean(up_hh) if up_hh else np.nan
    result["down_hh_pct"] = down_hh_avg
    result["up_hh_pct"] = up_hh_avg

    v_pattern = "balanced"
    if not pd.isna(down_hh_avg) and not pd.isna(up_hh_avg):
        v_diff = up_hh_avg - down_hh_avg
        if v_diff > 12:
            v_pattern = "crushes up, struggles down"
        elif v_diff > 6:
            v_pattern = "prefers up"
        elif v_diff < -12:
            v_pattern = "crushes down, struggles up"
        elif v_diff < -6:
            v_pattern = "prefers down"

    result["vertical_pattern"] = v_pattern
    return result


def swing_path_vulnerability(zone_metrics: Optional[Dict], sp, x_bin: int, y_bin: int, bats=None) -> float:
    """Calculate swing path vulnerability score for a zone (0-100).

    Higher score = MORE vulnerable (attack here).
    """
    if zone_metrics is None:
        return np.nan

    zm = zone_metrics.get((x_bin, y_bin), {})
    if zm.get("n_contact", 0) < 3:
        return np.nan

    scores = []
    weights = []

    la_std = zm.get("la_std")
    if la_std is not None and not pd.isna(la_std):
        consistency_vuln = np.clip((la_std - 8) / 12, 0, 1) * 100
        scores.append(consistency_vuln)
        weights.append(0.20)

    la_delta = zm.get("optimal_la_delta")
    if la_delta is not None and not pd.isna(la_delta):
        plane_vuln = np.clip(la_delta / 18, 0, 1) * 100
        scores.append(plane_vuln)
        weights.append(0.25)

    hh_pct = zm.get("hard_hit_pct")
    if hh_pct is not None and not pd.isna(hh_pct):
        hh_vuln = np.clip((45 - hh_pct) / 35, 0, 1) * 100
        scores.append(hh_vuln)
        weights.append(0.30)

    barrel_pct = zm.get("barrel_pct")
    if barrel_pct is not None and not pd.isna(barrel_pct):
        barrel_vuln = np.clip((12 - barrel_pct) / 12, 0, 1) * 100
        scores.append(barrel_vuln)
        weights.append(0.25)

    if sp:
        attack_angle = sp.get("attack_angle")
        path_adjust = sp.get("path_adjust", 0.0)
        contact_depth = sp.get("contact_depth")

        if attack_angle is not None and not pd.isna(attack_angle):
            can_adjust = abs(path_adjust) > 1.5 if path_adjust is not None else False
            if can_adjust:
                v_vuln = 50
            else:
                if attack_angle >= 12:
                    v_vuln = [85, 50, 25][y_bin]
                elif attack_angle >= 6:
                    v_vuln = [65, 50, 40][y_bin]
                elif attack_angle >= -2:
                    v_vuln = [50, 50, 50][y_bin]
                else:
                    v_vuln = [25, 50, 85][y_bin]
            scores.append(v_vuln)
            weights.append(0.15 if len(scores) > 2 else 0.30)

        if contact_depth is not None and not pd.isna(contact_depth):
            x_rel = _rel_xbin(x_bin, bats)
            if contact_depth > 2.0:
                h_vuln = [25, 50, 80][x_rel]
            elif contact_depth < -2.0:
                h_vuln = [80, 50, 25][x_rel]
            else:
                h_vuln = 50
            scores.append(h_vuln)
            weights.append(0.10 if len(scores) > 3 else 0.20)

    if not scores:
        return np.nan

    total_weight = sum(weights)
    return sum(s * w for s, w in zip(scores, weights)) / total_weight if total_weight > 0 else np.nan


def _weighted_score(parts, weights):
    """Weighted average ignoring NaN values."""
    vals = [(p, w) for p, w in zip(parts, weights) if pd.notna(p)]
    if not vals:
        return np.nan
    s = sum(p * w for p, w in vals)
    wsum = sum(w for _, w in vals)
    return s / wsum if wsum else np.nan


def _compute_zone_hole_detail(
    zdf: pd.DataFrame,
    zone_metrics,
    sp,
    xb: int,
    yb: int,
    bats,
) -> Dict[str, Any]:
    """Compute enhanced hole-score components for a single zone cell.

    Returns dict with score + component metrics, or empty dict if insufficient data.
    Uses enhanced formula: 35% whiff + 25% inv_SLG + 15% path_vuln + 15% EV_weakness + 10% low_swing%.
    """
    # Whiff%
    swings = zdf[zdf["PitchCall"].isin(SWING_CALLS)] if "PitchCall" in zdf.columns else pd.DataFrame()
    whiffs = zdf[zdf["PitchCall"] == "StrikeSwinging"] if "PitchCall" in zdf.columns else pd.DataFrame()
    whiff_pct = len(whiffs) / max(len(swings), 1) * 100 if len(swings) >= 5 else np.nan

    # Inverted SLG score (ceiling at 2.0 for better high-end discrimination)
    ab_df = zdf[zdf["PlayResult"].isin(_AB_RESULTS)] if "PlayResult" in zdf.columns else pd.DataFrame()
    slg_score = np.nan
    slg_raw = np.nan
    if len(ab_df) >= 5:
        tb = ab_df["PlayResult"].apply(_assign_total_bases).sum()
        slg_raw = tb / len(ab_df) if len(ab_df) > 0 else np.nan
        if pd.notna(slg_raw):
            slg_norm = np.clip(slg_raw / 2.0, 0, 1)
            slg_score = (1 - slg_norm) * 100

    # Swing path vulnerability
    path_vuln = swing_path_vulnerability(zone_metrics, sp, xb, yb, bats=bats)

    # EV weakness: low EV = more attackable
    ev_weakness = np.nan
    ev_mean = np.nan
    ip = zdf[zdf["PitchCall"] == "InPlay"] if "PitchCall" in zdf.columns else pd.DataFrame()
    if len(ip) >= 3 and "ExitSpeed" in ip.columns:
        ev_vals = pd.to_numeric(ip["ExitSpeed"], errors="coerce").dropna()
        if len(ev_vals) >= 3:
            ev_mean = float(ev_vals.mean())
            ev_weakness = np.clip((92 - ev_mean) / 20, 0, 1) * 100

    # Low swing%: zones they don't swing at are free strikes
    n_total = len(zdf)
    swing_rate = len(swings) / max(n_total, 1) if n_total >= 5 else np.nan
    low_swing_score = (1 - swing_rate) * 100 if pd.notna(swing_rate) else np.nan

    hs = _weighted_score(
        [whiff_pct, slg_score, path_vuln, ev_weakness, low_swing_score],
        [0.35, 0.25, 0.15, 0.15, 0.10],
    )
    if pd.isna(hs):
        return {}

    return {
        "score": float(hs),
        "swing_pct": float(swing_rate) if pd.notna(swing_rate) else 0.5,
        "whiff_pct": float(whiff_pct) if pd.notna(whiff_pct) else 0.0,
        "slg": float(slg_raw) if pd.notna(slg_raw) else 0.0,
        "ev_mean": float(ev_mean) if pd.notna(ev_mean) else 85.0,
        "n": n_total,
    }


def compute_hole_scores_3x3(
    pitch_df: pd.DataFrame,
    bats,
    sp=None,
    min_zone_n: int = 12,
) -> Dict[Tuple[int, int], float]:
    """Compute per-zone hole scores for a hitter (0-100, higher = more attackable).

    Uses enhanced formula: 35% whiff + 25% inv_SLG + 15% path_vuln + 15% EV_weakness + 10% low_swing%.
    Returns {(xb, yb): score} for zones with enough data.
    """
    if pitch_df is None or pitch_df.empty:
        return {}

    d = pitch_df.dropna(subset=["PlateLocSide", "PlateLocHeight"]).copy()
    if d.empty:
        return {}

    x_edges = np.array([-1.5, -0.5, 0.5, 1.5])
    y_edges = np.array([0.5, 2.0, 3.0, 4.5])
    d["xbin"] = np.clip(np.digitize(d["PlateLocSide"], x_edges) - 1, 0, 2)
    d["ybin"] = np.clip(np.digitize(d["PlateLocHeight"], y_edges) - 1, 0, 2)

    zone_metrics = compute_zone_swing_metrics(pitch_df, bats)

    result: Dict[Tuple[int, int], float] = {}
    for yb in range(3):
        for xb in range(3):
            zdf = d[(d["xbin"] == xb) & (d["ybin"] == yb)]
            if len(zdf) < min_zone_n:
                continue

            detail = _compute_zone_hole_detail(zdf, zone_metrics, sp, xb, yb, bats)
            if detail:
                result[(xb, yb)] = detail["score"]

    return result


def compute_all_pitch_type_holes(
    pitch_df: pd.DataFrame,
    bats,
    sp=None,
    min_zone_n_pt: int = 8,
    min_zone_n_agg: int = 12,
) -> Dict[str, Dict[Tuple[int, int], Dict]]:
    """Compute hole scores per pitch type AND aggregate ("ALL").

    For each pitch type with sufficient data, computes per-zone hole scores
    using the enhanced 35/25/15/15/10 formula.

    Returns: {pitch_type -> {(xb, yb) -> {score, swing_pct, whiff_pct, slg, ev_mean, n}}}
    "ALL" key contains aggregate across all pitch types.
    """
    if pitch_df is None or pitch_df.empty:
        return {}

    d = pitch_df.dropna(subset=["PlateLocSide", "PlateLocHeight"]).copy()
    if d.empty:
        return {}

    x_edges = np.array([-1.5, -0.5, 0.5, 1.5])
    y_edges = np.array([0.5, 2.0, 3.0, 4.5])
    d["xbin"] = np.clip(np.digitize(d["PlateLocSide"], x_edges) - 1, 0, 2)
    d["ybin"] = np.clip(np.digitize(d["PlateLocHeight"], y_edges) - 1, 0, 2)

    zone_metrics = compute_zone_swing_metrics(pitch_df, bats)
    result: Dict[str, Dict[Tuple[int, int], Dict]] = {}

    # Aggregate ("ALL") — uses standard min_zone_n
    agg_holes: Dict[Tuple[int, int], Dict] = {}
    for yb in range(3):
        for xb in range(3):
            zdf = d[(d["xbin"] == xb) & (d["ybin"] == yb)]
            if len(zdf) < min_zone_n_agg:
                continue
            detail = _compute_zone_hole_detail(zdf, zone_metrics, sp, xb, yb, bats)
            if detail:
                agg_holes[(xb, yb)] = detail
    if agg_holes:
        result["ALL"] = agg_holes

    # Per pitch type — uses lower threshold since pitch-type data is sparser
    pt_col = "TaggedPitchType"
    if pt_col not in d.columns:
        return result

    for pt in d[pt_col].dropna().unique():
        pt_str = str(pt).strip()
        if not pt_str or pt_str.upper() in {"", "UNDEFINED", "OTHER", "UNKNOWN"}:
            continue
        pt_df = d[d[pt_col] == pt]
        if len(pt_df) < min_zone_n_pt:
            continue

        pt_holes: Dict[Tuple[int, int], Dict] = {}
        for yb in range(3):
            for xb in range(3):
                zdf = pt_df[(pt_df["xbin"] == xb) & (pt_df["ybin"] == yb)]
                if len(zdf) < min_zone_n_pt:
                    continue
                detail = _compute_zone_hole_detail(zdf, zone_metrics, sp, xb, yb, bats)
                if detail:
                    pt_holes[(xb, yb)] = detail
        if pt_holes:
            result[pt_str] = pt_holes

    return result


# ── Count groupings for count-zone analysis ──────────────────────────────────

_COUNT_GROUPS = {
    "early": {(0, 0), (1, 0), (0, 1), (1, 1)},
    "two_strike": {(0, 2), (1, 2), (2, 2), (3, 2)},
    "hitter_count": {(2, 0), (2, 1), (3, 0), (3, 1)},
}


def _count_group_for(balls: int, strikes: int) -> str:
    """Map a (balls, strikes) count to a count group."""
    ct = (balls, strikes)
    for group, counts in _COUNT_GROUPS.items():
        if ct in counts:
            return group
    return "early"  # fallback


def compute_count_zone_metrics(
    pitch_df: pd.DataFrame,
    min_zone_n: int = 5,
) -> Dict[str, Dict[Tuple[int, int], Dict]]:
    """Compute swing metrics by count group and zone.

    Groups counts into 3 categories (early, two_strike, hitter_count) and
    computes per-zone swing_rate, whiff_rate, slg, n.

    Returns: {count_group -> {(xb, yb) -> {swing_rate, whiff_rate, slg, n}}}
    """
    if pitch_df is None or pitch_df.empty:
        return {}

    required_cols = {"PlateLocSide", "PlateLocHeight", "Balls", "Strikes"}
    if not required_cols.issubset(pitch_df.columns):
        return {}

    d = pitch_df.dropna(subset=["PlateLocSide", "PlateLocHeight", "Balls", "Strikes"]).copy()
    if d.empty:
        return {}

    x_edges = np.array([-1.5, -0.5, 0.5, 1.5])
    y_edges = np.array([0.5, 2.0, 3.0, 4.5])
    d["xbin"] = np.clip(np.digitize(d["PlateLocSide"], x_edges) - 1, 0, 2)
    d["ybin"] = np.clip(np.digitize(d["PlateLocHeight"], y_edges) - 1, 0, 2)

    d["_balls"] = pd.to_numeric(d["Balls"], errors="coerce").fillna(0).astype(int)
    d["_strikes"] = pd.to_numeric(d["Strikes"], errors="coerce").fillna(0).astype(int)
    d["_count_group"] = d.apply(lambda r: _count_group_for(r["_balls"], r["_strikes"]), axis=1)

    result: Dict[str, Dict[Tuple[int, int], Dict]] = {}
    for cg in ("early", "two_strike", "hitter_count"):
        cg_df = d[d["_count_group"] == cg]
        if cg_df.empty:
            continue

        cg_zones: Dict[Tuple[int, int], Dict] = {}
        for yb in range(3):
            for xb in range(3):
                zdf = cg_df[(cg_df["xbin"] == xb) & (cg_df["ybin"] == yb)]
                n = len(zdf)
                if n < min_zone_n:
                    continue

                swings = zdf[zdf["PitchCall"].isin(SWING_CALLS)] if "PitchCall" in zdf.columns else pd.DataFrame()
                whiffs = zdf[zdf["PitchCall"] == "StrikeSwinging"] if "PitchCall" in zdf.columns else pd.DataFrame()
                swing_rate = len(swings) / max(n, 1)
                whiff_rate = len(whiffs) / max(len(swings), 1) if len(swings) >= 3 else 0.0

                slg = 0.0
                ab_df = zdf[zdf["PlayResult"].isin(_AB_RESULTS)] if "PlayResult" in zdf.columns else pd.DataFrame()
                if len(ab_df) >= 3:
                    tb = ab_df["PlayResult"].apply(_assign_total_bases).sum()
                    slg = tb / len(ab_df) if len(ab_df) > 0 else 0.0

                cg_zones[(xb, yb)] = {
                    "swing_rate": float(swing_rate),
                    "whiff_rate": float(whiff_rate),
                    "slg": float(slg),
                    "n": n,
                }

        if cg_zones:
            result[cg] = cg_zones

    return result


def compute_zone_vulnerability_summary(
    pitch_df: pd.DataFrame, bats, sp=None,
) -> Dict[str, Any]:
    """Compute a condensed zone vulnerability summary for the decision engine.

    Returns dict with:
    - vuln_up, vuln_down, vuln_inside, vuln_away: avg vulnerability 0-100
    - vuln_chase_low, vuln_chase_away: chase zone vulnerability
    - horizontal_pattern, vertical_pattern: string descriptions
    - available: bool (True if enough data)
    """
    result: Dict[str, Any] = {"available": False}

    if pitch_df is None or pitch_df.empty:
        return result

    zone_metrics = compute_zone_swing_metrics(pitch_df, bats)
    if zone_metrics is None:
        return result

    patterns = analyze_zone_patterns(zone_metrics, bats)
    result["horizontal_pattern"] = patterns.get("horizontal_pattern", "balanced")
    result["vertical_pattern"] = patterns.get("vertical_pattern", "balanced")

    # Compute per-region vulnerability scores (average across relevant zones)
    def _avg_vuln(positions):
        vals = []
        for xb, yb in positions:
            v = swing_path_vulnerability(zone_metrics, sp, xb, yb, bats=bats)
            if not np.isnan(v):
                vals.append(v)
        return np.mean(vals) if vals else np.nan

    bats_label = _fmt_bats(bats)

    # Map "up" = top row (ybin=2), "down" = bottom row (ybin=0)
    result["vuln_up"] = _avg_vuln([(0, 2), (1, 2), (2, 2)])
    result["vuln_down"] = _avg_vuln([(0, 0), (1, 0), (2, 0)])

    # Inside/away depend on batter handedness
    if bats_label == "L":
        inside_xbs = [2]  # right side is inside for LHH
        away_xbs = [0]
    else:
        inside_xbs = [0]
        away_xbs = [2]

    result["vuln_inside"] = _avg_vuln([(xb, yb) for xb in inside_xbs for yb in range(3)])
    result["vuln_away"] = _avg_vuln([(xb, yb) for xb in away_xbs for yb in range(3)])

    # Chase zones: low = ybin 0 at extremes, away = outer column off-plate
    result["vuln_chase_low"] = _avg_vuln([(0, 0), (1, 0), (2, 0)])
    result["vuln_chase_away"] = _avg_vuln([(xb, yb) for xb in away_xbs for yb in range(3)])

    # Mark available if we have at least some valid vulnerability scores
    has_data = sum(1 for k in ["vuln_up", "vuln_down", "vuln_inside", "vuln_away"] if not np.isnan(result.get(k, np.nan)))
    result["available"] = has_data >= 2

    return result
